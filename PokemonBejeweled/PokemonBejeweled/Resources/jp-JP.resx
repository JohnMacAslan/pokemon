<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="Done" xml:space="preserve">
    <value>行わ!</value>
  </data>
  <data name="Five_Minutes" xml:space="preserve">
    <value>5分</value>
  </data>
  <data name="Game_Title" xml:space="preserve">
    <value>最もかわいいポケモンスワップ!!!</value>
  </data>
  <data name="Hint" xml:space="preserve">
    <value>ヒント</value>
  </data>
  <data name="Instructions" xml:space="preserve">
    <value>説明書</value>
  </data>
  <data name="Instruction_Content" xml:space="preserve">
    <value>ゲームの目的は、行と同じポケモンの列を作ることによってポイントを蓄積することである。これは、3つの行または列を作るためにスワップされた隣接ポケモンによって達成される。ボーナスポイントは、以上の3の行または列のために授与されます。行または列が行われると、それらのポケモンがキャプチャして消滅する。これら上記のポケモンは落ちるでしょうし、新しいものには、画面の上からで落ちるでしょう。

4の行または列がなされた場合、スワップポケモンは、その最初の進化の形に進化していきます。このポケモンは、その進化チェーン内の他のポケモンと共に使用することができる。使用した場合は、それを囲むすべてのポケモンをキャプチャします。

5の行または列がなされた場合は、スワップポケモンは同上になるであろう。同上は、他のポケモンといつでも交換することができます。すると、同上のと交換されたことをポケモンの進化チェーン内のポケモンの全てが取得される。ますますポイントが同上上昇を交換することによって捕獲ポケモン数として授与されます。

6の行または列がなされた場合、一番左の（行の場合）またはアッパーは（列であれば）ほとんどのポケモンは、その第二の進化形に進化していきます。このポケモンは、その進化チェーン内の他のポケモンと共に使用することができる。使用される場合、それはインチであること板のすべての同じ行のポケモンと列をキャプチャし

新しいゲームのボタンをクリックして、新しいゲームを開始します。これは、あなたのスコアとタイマーがリセットされます。

制限時間は、画面の左側にあるオプションで設定することができる。

ゲームを一時停止するタイマーを一時停止し、ビューから画面が非表示になります。ボタンを再開するにはもう一度クリックすることができます。

残っている動きがある場合は、ヒントを求めする動きが表示されます。このコストを指しますので、それを賢く使う！残って動きがない場合、ボタンはそう言うだろうと何ポイントは差し引かれません。</value>
  </data>
  <data name="Language" xml:space="preserve">
    <value>言語</value>
  </data>
  <data name="Main_Menu" xml:space="preserve">
    <value>メインメニュー</value>
  </data>
  <data name="New_Game" xml:space="preserve">
    <value>新しいゲーム</value>
  </data>
  <data name="No_Moves" xml:space="preserve">
    <value>一手がない</value>
  </data>
  <data name="One_Minute" xml:space="preserve">
    <value>1分</value>
  </data>
  <data name="Pause" xml:space="preserve">
    <value>間を置く</value>
  </data>
  <data name="Quit" xml:space="preserve">
    <value>よす</value>
  </data>
  <data name="Resume" xml:space="preserve">
    <value>やり直す</value>
  </data>
  <data name="Scoreboard" xml:space="preserve">
    <value>スコアボード</value>
  </data>
  <data name="Ten_Minutes" xml:space="preserve">
    <value>10分</value>
  </data>
  <data name="Time_Left" xml:space="preserve">
    <value>余日</value>
  </data>
  <data name="Undo" xml:space="preserve">
    <value>アンドゥ</value>
  </data>
  <data name="Unlimited" xml:space="preserve">
    <value>限りない</value>
  </data>
  <data name="Window_Title" xml:space="preserve">
    <value>ポケモンスワップ</value>
  </data>
</root>